<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zchoi.github.io/github.io</id>
    <title>Waldeinsamkeit</title>
    <updated>2020-03-23T14:19:02.430Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zchoi.github.io/github.io"/>
    <link rel="self" href="https://zchoi.github.io/github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zchoi.github.io/github.io/images/avatar.png</logo>
    <icon>https://zchoi.github.io/github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Waldeinsamkeit</rights>
    <entry>
        <title type="html"><![CDATA[先序+中序建立二叉树]]></title>
        <id>https://zchoi.github.io/github.io/post/xian-xu-zhong-xu-jian-li-er-cha-shu/</id>
        <link href="https://zchoi.github.io/github.io/post/xian-xu-zhong-xu-jian-li-er-cha-shu/">
        </link>
        <updated>2020-03-23T14:13:57.000Z</updated>
        <content type="html"><![CDATA[<p>以递归的思想：</p>
<pre><code>node *create(int preL,int preR,int inL,int inR){   //先中序的节点序列
	if(preL&gt;preR){  
		return NULL;
	}
	node *root=(node *)malloc(sizeof(struct node));    //首先创建根节点
	root-&gt;val=pre[preL];                         //根节点的值是先序的第一个节点
	int k;          
	for(k=inL;k&lt;=inR;k++){
		if(in[k]==pre[preL])  //找到中序的根节点位置
			break;
	}
	int numLeft=k-inL;
        //递归左子树，找左子树的根节点在先序和中序中的位置
	root-&gt;lchild=create(preL+1,preL+numLeft,inL,k-1); 
        //递归右子树
	root-&gt;rchild=create(preL+numLeft+1,preR,k,inR);
	return root;
}
</code></pre>
<p>Tip：后序和中序构建二叉树一样，只不过注意根节点是后序的最后一个元素</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DFS背包问题]]></title>
        <id>https://zchoi.github.io/github.io/post/dfs-bei-bao-wen-ti/</id>
        <link href="https://zchoi.github.io/github.io/post/dfs-bei-bao-wen-ti/">
        </link>
        <updated>2020-03-23T13:56:07.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>现要将一个背包装若干物品，每个物品都有相应的价值，问在不超过背包容量V的情况下，怎样装物品，使背包价值最大？</strong><br>
背包容量：V<br>
物品:things[n]<br>
重量：weight[n]<br>
价值：value[n]</p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>现要将一个背包装若干物品，每个物品都有相应的价值，问在不超过背包容量V的情况下，怎样装物品，使背包价值最大？</strong><br>
背包容量：V<br>
物品:things[n]<br>
重量：weight[n]<br>
价值：value[n]</p>
<!-- more -->
<p>答：用到了DFS。面对物品index（1&lt;=index&lt;=n)，可以不装，也可以装。递归边界：背包装到了最后一件index=n,若没有超过最大容量且当前价值大于max_value，则更新max_value,并返回。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
using namespace std;

void DFS(int,int ,int);
int n, V, maxValue=0; //物品件数，背包容量，最大价值maxvalue;
const int maxn=30;
int weight[maxn],value[maxn];
int main(){
	printf(&quot;input the capacity of bags and  number of things:&quot;);
	scanf(&quot;%d %d&quot;,&amp;V,&amp;n);
	printf(&quot;input the weight of each thing one by one:\n&quot;);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;weight[i]);
	}
	printf(&quot;and input value of each thing:\n&quot;);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;value[i]);
	}
	DFS(0,0,0);
	printf(&quot;max value of bags:%d\n&quot;,maxValue);

}
void DFS(int index,int sum,int sumc){
	if(index==n){
		if(sum&lt;=V&amp;&amp;sumc&gt;maxValue){
			maxValue=sumc;
		}
		return;
	}
	DFS(index+1,sum+weight[index],sumc+value[index]);
	DFS(index+1,sum,sumc);
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu安装VMware Tools]]></title>
        <id>https://zchoi.github.io/github.io/post/Ubuntu安装VMware Tools/</id>
        <link href="https://zchoi.github.io/github.io/post/Ubuntu安装VMware Tools/">
        </link>
        <updated>2020-02-17T02:10:59.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="首先可能遇到的问题">首先可能遇到的问题🙋‍♂</h2>
<pre><code>&quot;重新安装VMware Tools&quot;按钮显示灰色
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zchoi.github.io/github.io/post-images/1581905632349.png" alt="" loading="lazy"></figure>
<h2 id="解决办法">解决办法💁‍♂</h2>
<pre><code>1.关闭虚拟机；
2.在虚拟机设置分别设置CD/DVD、CD/DVD2和软盘为自动检测三个步骤；
3.再重启虚拟机，灰色字即点亮。
</code></pre>
<p><img src="https://zchoi.github.io/github.io/post-images/1581905783155.png" alt="" loading="lazy"><br>
<img src="https://zchoi.github.io/github.io/post-images/1581905914067.png" alt="" loading="lazy"></p>
<p><strong>Tips</strong>:如果默认就是自动检测，无法安装VMware Tools，这时候可以把CD/DVD设置成VMware安装目录中的linux.iso</p>
<!-- more -->
<h2 id="vmware-tools安装">Vmware Tools安装🌳</h2>
<pre><code>1.按钮点亮后，点击安装，开启虚拟机，在左侧VMware Tools会看到类似如下文件包&quot;VMwareTools-10.2.5-8068393.tar.gz&quot;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://zchoi.github.io/github.io/post-images/1581906670194.png" alt="" loading="lazy"></figure>
<pre><code>2.打开终端，输入命令&quot;tar zxf VMwareTools-10.2.5-8068393.tar.gz&quot;

3.之后会生成文件&quot;vmware-tools-distrib&quot;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://zchoi.github.io/github.io/post-images/1581906714145.png" alt="" loading="lazy"></figure>
<pre><code>4.&quot;cd vmware-tools-distrib&quot;
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://zchoi.github.io/github.io/post-images/1581907318102.png" alt="" loading="lazy"></figure>
<pre><code>5.&quot;sudo ./vmware-install.pl&quot;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://zchoi.github.io/github.io/post-images/20181107000903442.png" alt="" loading="lazy"></figure>
<pre><code>6.一路next，遇到y/n输入选项，输入y，回车。出现如下命令意味着VMware Tools安装成功。
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://zchoi.github.io/github.io/post-images/1581906934402.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://zchoi.github.io/github.io/post/hello-gridea/</id>
        <link href="https://zchoi.github.io/github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>